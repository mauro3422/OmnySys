
#### 3.5.6: ValidaciÃ³n en Test Cases

**Validar en scenario-2-semantic**:
```bash
# Ejecutar anÃ¡lisis estÃ¡tico
node src/layer-a-static/indexer.js test-cases/scenario-2-semantic/src

# Expected results:
âœ… 3 shared_state connections detectadas
âœ… 3 event_listener connections detectadas
âœ… 6 files con side effects
âœ… Risk scores: 4.0-7.5 range
âœ… Confidence: 1.0 (todas detectadas por scripts)

# Comparar contra expected-semantic-connections.json
âœ… 100% match (scripts detectan TODO en este caso simple)
```

**Performance esperado**:
- AnÃ¡lisis completo: <200ms para 6 archivos
- Escalabilidad: ~30ms por archivo (lineal)
- Zero external dependencies (sin modelo IA)

---

## FASE 4: MCP Server + Context Delivery System

**Objetivo**: Hacer que la IA reciba contexto relevante ANTES de editar cÃ³digo.

**El Problema CrÃ­tico**:
Cuando vas a editar `CameraState.js` en un proyecto de 500 archivos, Â¿cuÃ¡les de esos 500 archivos son RELEVANTES? No puedes pasar todos (contexto saturado), pero necesitas los correctos.

### 4.1: MCP Server BÃ¡sico

**Entregables**:
- Servidor MCP que expone el systemMap vÃ­a Model Context Protocol
- Endpoints principales:
  - `getSystemMap()` - Retorna mapa completo (para debugging)
  - `getFileContext(filePath)` - Contexto relevante para UN archivo
  - `getImpactAnalysis(filePath)` - AnÃ¡lisis de impacto de editar un archivo
  - `getQualityReport()` - Reporte de calidad del proyecto

**Stack tÃ©cnico**:
- `@modelcontextprotocol/sdk` (MCP SDK oficial)
- Node.js server con stdio transport
- Lee `system-map.json` y `system-map-analysis.json`

**Ejemplo de uso**:
```javascript
// La IA invoca herramienta MCP
mcp.getFileContext("src/game/CameraState.js")

// Respuesta:
{
  "file": "src/game/CameraState.js",
  "relevantFiles": ["RenderEngine.js", "MinimapUI.js", "PlayerMovement.js"],
  "warnings": ["HOTSPOT: Used by 15 files"],
  "summary": "Camera state affects rendering, minimap, and player tracking"
}
```

### 4.2: Context Selector - Sistema de Relevancia

**El cerebro del sistema**: Decide QUÃ‰ contexto pasar y CUÃNDO.

#### Algoritmo 1: Relevancia por Distancia (Graph Distance)

**Estrategia**: Filtrar por proximidad en el grafo de dependencias

```
TIER 0 (Distancia 0) - El archivo objetivo
â”œâ”€â”€ CameraState.js âœ… SIEMPRE

TIER 1 (Distancia 1) - Dependencias directas
â”œâ”€â”€ usedBy: [RenderEngine.js, MinimapUI.js] âœ… SIEMPRE
â”œâ”€â”€ dependsOn: [Vector2D.js, MathUtils.js] âœ… SIEMPRE

TIER 2 (Distancia 2) - Dependencias transitivas
â”œâ”€â”€ usedBy: [GameLoop.js, SceneManager.js] âš ï¸ SELECTIVO
â”œâ”€â”€ dependsOn: [Constants.js] âš ï¸ SELECTIVO

TIER 3+ (Distancia 3+)
â”œâ”€â”€ Demasiado lejos âŒ IGNORAR (excepto si es HOTSPOT)
```

**Regla de oro**: Pasar TIER 0 + TIER 1 completo + TIER 2 filtrado por score

#### Algoritmo 2: Relevancia por Scoring

**Estrategia**: Calcular score de relevancia para cada archivo

```javascript
function calculateRelevanceScore(file, targetFile, analysis) {
  let score = 100; // Base score

  // ðŸ”¥ BOOSTS (aumentan relevancia)
  if (isDirectDependency(file, targetFile)) score += 100;
  if (isHotspot(file, analysis)) score += 50;
  if (hasHighCoupling(file, targetFile, analysis)) score += 30;
  if (sharesConstants(file, targetFile)) score += 20;
  if (sharesTypes(file, targetFile)) score += 15;

  // ðŸ§Š PENALTIES (reducen relevancia)
  if (isTestFile(file)) score -= 50;
  if (isConfigFile(file)) score -= 40;
  if (isBuildTool(file)) score -= 60;
  if (distance > 2) score -= 30 * (distance - 2);

  return Math.max(0, score);
}
```

**Threshold**: Solo pasar archivos con `score >= 100`

#### Algoritmo 3: Symbol-Level Filtering

**Problema**: No todas las dependencias son iguales

```javascript
// CameraState.js exporta:
export const position = { x, y };      // Usado por 10 archivos
export const zoom = 1.0;               // Usado por 3 archivos
export function toJSON() { ... }       // Usado por 1 archivo (SaveManager)

// Si vas a editar position:
âœ… Pasar: MinimapUI.js, PlayerMovement.js (usan position)
âŒ NO pasar: SaveManager.js (solo usa toJSON)
```

**ImplementaciÃ³n**:
- Usar `constantUsage`, `objectExports` del anÃ¡lisis
- Preguntar: "Â¿QuÃ© sÃ­mbolo especÃ­fico vas a modificar?"
- Filtrar solo archivos que usan ESE sÃ­mbolo

#### Algoritmo 4: Risk-Based Expansion

**Estrategia**: Si el archivo es CRÃTICO, ampliar contexto

```javascript
if (isHotspot(targetFile) && callers >= 15) {
  // Archivo super crÃ­tico - pasar MÃS contexto
  maxFiles = 15;
  includeAllCallers = true;
  warnings.push("âš ï¸ CRITICAL FILE: 15+ files depend on this");
}

if (hasCircularDependency(targetFile)) {
  // Dependency hell - advertir
  warnings.push("ðŸ”´ CIRCULAR DEPENDENCY: Review carefully");
  includeCircularFiles = true;
}

if (couplingStrength >= 5) {
  // Alto acoplamiento - pasar archivos acoplados
  includeCoupledFiles = true;
  warnings.push("âš ï¸ HIGH COUPLING: Changes may cascade");
}
```

### 4.3: Context Injector - Formateo para IA

**Entregables**:
- Sistema que formatea el contexto de forma legible para la IA
- Diferentes niveles de detalle segÃºn la situaciÃ³n

#### Formato EstÃ¡ndar (Para ediciones normales)

```markdown
ðŸ§­ CONTEXT FOR EDITING: src/game/CameraState.js

ðŸ“ AFFECTED FILES (4):
  1. src/game/RenderEngine.js (imports: position, zoom, rotation)
     - Direct dependency
     - Hotspot: 23 callers

  2. src/ui/MinimapUI.js (imports: position)
     - Direct dependency
     - High coupling detected

  3. src/player/PlayerMovement.js (imports: followTarget, position)
     - Direct dependency

  4. src/effects/CameraShake.js (imports: shake method)
     - Transitive dependency

âš ï¸  WARNINGS:
  - CameraState.js is a HOTSPOT (used by 15 files)
  - High coupling with RenderEngine.js (bidirectional)
  - Circular function dependency detected in updateCamera()

ðŸ’¡ RECOMMENDATIONS:
  - Test camera movement after changes
  - Verify minimap sync
  - Check player tracking behavior
  - Run integration tests

ðŸ“Š QUALITY:
  - Impact Level: HIGH (15 files affected)
  - Risk Score: 7/10
  - Test Coverage: 85%
```

#### Formato Compacto (Para archivos simples)

```markdown
ðŸ§­ CameraState.js â†’ Affects: RenderEngine.js, MinimapUI.js (2 files)
âš ï¸  Hotspot (15 callers) - Test carefully
```

#### Formato Expandido (Para archivos crÃ­ticos)

Incluir:
- Function-level call graph
- Constant usage analysis
- Type dependencies (TypeScript)
- Recent change history (git)
- Related test files

### 4.4: Hook Integration - Interceptar Ediciones

**Entregables**:
- Hook que intercepta cuando la IA va a editar cÃ³digo
- Inyecta contexto ANTES de que la IA escriba

**Flujo**:
```
1. IA invoca herramienta Edit(file="CameraState.js", ...)
2. Hook intercepta ANTES de ejecutar
3. Consulta MCP Server: getFileContext("CameraState.js")
4. Recibe contexto relevante
5. Prepend contexto al prompt de la IA
6. IA ahora tiene contexto completo
7. Ejecuta Edit con conocimiento total
```

**ImplementaciÃ³n**:
- Usar pre-tool-execution hooks (si disponible en SDK)
- O usar prompt engineering: "Before editing X, always check context for X"

### 4.5: Incremental Context - Ajuste DinÃ¡mico

**Problema**: A veces la IA necesita MÃS contexto si falla

**Estrategia**: Sistema de contexto incremental

```javascript
let contextDepth = 1; // Empezar conservador

// Si la IA falla o pide ayuda
if (errorDetected || aiAsksForHelp) {
  contextDepth++;
  expandContext(); // Incluir TIER 2, TIER 3
}

// Si la IA tiene Ã©xito
if (testsPass && noErrors) {
  contextDepth = 1; // Volver a modo conservador
}
```

### 4.6: CachÃ© y Performance

**Entregables**:
- Sistema de cachÃ© para consultas repetidas
- Pre-computar contextos comunes

**Optimizaciones**:
```javascript
// CachÃ© de contextos frecuentes
const contextCache = new LRU(maxSize: 100);

// Pre-compute para archivos hotspot
for (const hotspot of analysis.hotspots) {
  contextCache.set(hotspot.file, computeContext(hotspot.file));
}

// Invalidar cachÃ© solo cuando archivo cambia
fileWatcher.on('change', (file) => {
  contextCache.invalidate(file);
  // Re-computar solo archivos afectados
});
```

---

## FASE 5: Semantic Layer - IA para Casos Complejos y SÃ­ntesis

**Objetivo**: Usar IA local (LFM2.5-Thinking) SOLO para casos complejos y sÃ­ntesis/verificaciÃ³n.

**Estrategia HÃ­brida - 80/20 Rule**:
```
Phase 3.5 (Scripts)             Phase 5 (IA)
â”œâ”€ 80% de detecciÃ³n             â”œâ”€ 20% casos complejos
â”œâ”€ Zero cost                    â”œâ”€ SÃ­ntesis de resultados
â”œâ”€ <200ms                       â”œâ”€ VerificaciÃ³n de findings
â””â”€ Patterns obvios              â””â”€ Context understanding
```

### 5.1: Casos que Requieren IA

**CuÃ¡ndo usar IA (no scripts)**:

```javascript
// âŒ Scripts NO pueden detectar:

// 1. IndirecciÃ³n
const state = window.gameState;
state.score = 10;  // Â¿state === window.gameState?

// 2. CÃ³digo dinÃ¡mico
const propName = config.stateProp;
window[propName] = { score: 0 };  // Runtime value

// 3. Chains complejas
const obj = getStateObject();  // Â¿QuÃ© devuelve?
obj.score = 10;

// 4. Template strings
const eventName = `game:${action}`;  // Â¿QuÃ© valor tiene action?
window.eventBus.on(eventName, handler);
```

**Triggers para anÃ¡lisis con IA**:
```javascript
function shouldUseAI(file, staticAnalysis) {
  return (
    file.hasIndirection ||              // Variables como proxies
    file.hasDynamicProperties ||        // window[varName]
    file.complexityScore > 7 ||         // Alto riesgo
    staticAnalysis.lowConfidence ||     // Scripts no seguros
    file.isHotspot && hasSemanticRisk   // CrÃ­tico + sospechoso
  );
}
```

### 5.2: IA para SÃ­ntesis y VerificaciÃ³n

**Uso principal**: Enriquecer resultados de scripts, no reemplazarlos.

**Tareas de IA**:
```javascript
// 1. SÃ­ntesis
"Estos 5 archivos acceden a window.gameState. Resumen:
 - Player.js ESCRIBE score (high impact)
 - UI.js LEE score (medium impact)
 - Analytics.js LEE para metrics (low impact)
 Riesgo: Race condition si Player modifica mientras UI lee."

// 2. VerificaciÃ³n de false positives
StaticAnalysis: "DetectÃ© shared state en A.js y B.js"
AI: "Verificado. B.js efectivamente depende del estado de A.
     Confidence: 0.95"

// 3. Context understanding
StaticAnalysis: "window.eventBus.emit('user:login', data)"
AI: "Este evento es crÃ­tico para autenticaciÃ³n. Impacta:
     - Session management
     - Authorization flow
     - Analytics tracking
     Severity: CRITICAL (no solo 'high')"

// 4. Recommendations
"Refactoring suggestion: Considera usar un state manager
 en lugar de window.gameState para mejor testability."
```

### 5.3: EvaluaciÃ³n de Modelos (Actualizado)

**Modelo seleccionado**: **LFM2.5-1.2B-Thinking** (ver docs/SEMANTIC_LAYER_MODELS.md)

**Por quÃ©:**
- âœ… +39% mejor razonamiento que Instruct
- âœ… +16% mejor tool use (JSON output)
- âœ… Thinking traces para debug
- âœ… <900MB memoria
- âœ… Ya evaluado y documentado

**Uso limitado**:
- Solo 10-20% de archivos (casos complejos)
- SÃ­ntesis al final del anÃ¡lisis
- VerificaciÃ³n bajo demanda

### 5.4: Detector de Casos Complejos

**Casos que anÃ¡lisis estÃ¡tico NO detecta**:

```javascript
// Caso 1: Estado compartido via store
// GameStore.js
export const gameState = { score: 0 };

// Player.js - NO importa GameStore
function updateScore() {
  window.gameState.score++; // âŒ AnÃ¡lisis estÃ¡tico no lo ve
}

// UI.js - NO importa Player
function displayScore() {
  return window.gameState.score; // âŒ ConexiÃ³n no obvia
}
```

**Prompt para IA (casos complejos)**:
```
AnÃ¡lisis estÃ¡tico ya detectÃ³:
- window.gameState accedido en Player.js (lÃ­nea 15) y UI.js (lÃ­nea 23)
- Confidence: 1.0 (determinÃ­stico)

Tu tarea:
1. Verificar si hay conexiones ADICIONALES no detectadas
2. Analizar IMPACTO de estas conexiones
3. Sugerir severity ajustada por contexto

Code context:
[cÃ³digo relevante aquÃ­]

Output JSON:
{
  "additionalConnections": [...],  // Solo si encontrÃ¡s algo nuevo
  "verification": {
    "staticFindingsCorrect": true,
    "contextAnalysis": "Player modifica score, UI lo lee en tiempo real...",
    "suggestedSeverity": "critical",  // vs "high" del static
    "reasoning": "UI puede mostrar datos stale si..."
  },
  "recommendations": [...]
}
```

