#!/usr/bin/env node

/**
 * CogniSystem MCP Server - Protocolo MCP Real
 * 
 * ImplementaciÃ³n completa del Model Context Protocol (MCP) SDK.
 * Este servidor expone las tools de CogniSystem via protocolo estÃ¡ndar MCP.
 * 
 * Uso:
 *   node mcp-server-sdk.js /path/to/project
 * 
 * IntegraciÃ³n con Kimi/Claude:
 *   - Protocolo: MCP stdio
 *   - Tools: get_impact_map, analyze_change, explain_connection, etc.
 *   - Auto-inicia Orchestrator interno
 */

import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
  ErrorCode,
  McpError
} from '@modelcontextprotocol/sdk/types.js';

import { Orchestrator } from '../core/orchestrator.js';
import { UnifiedCacheManager } from '../core/unified-cache-manager.js';
import {
  getProjectMetadata,
  getFileAnalysis,
  getAllConnections,
  getRiskAssessment,
  getFileDependencies,
  findFiles
} from '../layer-a-static/storage/query-service.js';
import { loadAIConfig, LLMClient } from '../ai/llm-client.js';

import path from 'path';
import fs from 'fs/promises';
import { fileURLToPath } from 'url';

// ============================================================
// MCP Server Implementation
// ============================================================

class CogniSystemMCPRuntime {
  constructor(projectPath) {
    this.projectPath = projectPath;
    this.orchestrator = null;
    this.cache = null;
    this.server = null;
    this.transport = null;
  }

  /**
   * Initialize the MCP server
   */
  async initialize() {
    console.error('\nðŸš€ CogniSystem MCP Server - Initializing...');
    console.error(`ðŸ“‚ Project: ${this.projectPath}`);

    // Step 1: Check if project has files
    const fileCount = await this.countProjectFiles();
    console.error(`ðŸ“Š Found ${fileCount} JS/TS files in project`);

    if (fileCount === 0) {
      console.error('âš ï¸  WARNING: No JavaScript/TypeScript files found!');
      console.error('   The project appears to be empty or not a JS/TS project.');
    }

    // Step 2: Auto-start LLM Server
    console.error('\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
    console.error('STEP 1: AI Server Setup');
    console.error('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
    await this.autoStartLLM();

    // Step 3: Initialize Orchestrator
    console.error('\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
    console.error('STEP 2: Initialize Orchestrator');
    console.error('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
    this.orchestrator = new Orchestrator(this.projectPath, {
      enableFileWatcher: true,
      enableWebSocket: false,
      autoStartLLM: false // Already started above
    });
    await this.orchestrator.initialize();
    console.error('âœ… Orchestrator initialized');

    // Step 4: Initialize Cache
    console.error('\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
    console.error('STEP 3: Initialize Cache');
    console.error('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
    this.cache = new UnifiedCacheManager(this.projectPath);
    await this.cache.initialize();
    console.error('âœ… Cache initialized');

    // Step 5: Check for existing analysis
    console.error('\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
    console.error('STEP 4: Check Analysis Status');
    console.error('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
    const hasAnalysis = await this.hasExistingAnalysis();
    
    if (hasAnalysis) {
      const metadata = await getProjectMetadata(this.projectPath);
      const totalFiles = metadata?.metadata?.totalFiles || 0;
      console.error(`âœ… Found existing analysis: ${totalFiles} files indexed`);
      
      // Even with existing analysis, check if all current files are indexed
      const fileCount = await this.countProjectFiles();
      if (fileCount > totalFiles) {
        console.error(`âš ï¸  Project has ${fileCount} files but only ${totalFiles} analyzed`);
        console.error('ðŸ”„ Starting incremental indexing...');
        this.orchestrator.startBackgroundIndexing();
      }
    } else {
      console.error('âš ï¸  No existing analysis found');
      console.error('ðŸ”„ Starting background indexing...');
      console.error('   â³ This may take 1-5 minutes depending on project size');
      this.orchestrator.startBackgroundIndexing();
    }
    
    // Log initial status
    const status = this.orchestrator.getStatus();
    console.error(`\nðŸ“Š Initial Status:`);
    console.error(`   - Queue size: ${status.queueSize}`);
    console.error(`   - Is indexing: ${status.isIndexing}`);
    console.error(`   - Current job: ${status.currentJob ? status.currentJob.filePath : 'none'}`);

    // Setup MCP Server
    this.server = new Server(
      {
        name: 'cognisystem',
        version: '3.0.0'
      },
      {
        capabilities: {
          tools: {}
        }
      }
    );

    // Register handlers
    this.setupToolHandlers();

    // Error handling
    this.server.onerror = (error) => {
      console.error('[MCP Error]', error);
    };

    process.on('SIGINT', async () => {
      await this.shutdown();
      process.exit(0);
    });

    console.error('âœ… MCP Server initialized and ready\n');
  }

  /**
   * Setup MCP tool handlers
   */
  setupToolHandlers() {
    // List available tools
    this.server.setRequestHandler(ListToolsRequestSchema, async () => {
      return {
        tools: [
          {
            name: 'get_impact_map',
            description: 'Returns a complete impact map for a file - what other files are affected if this file is modified. Automatically analyzes the file if not already done.',
            inputSchema: {
              type: 'object',
              properties: {
                filePath: {
                  type: 'string',
                  description: 'Relative path to the file (e.g., "src/components/Camera.js")'
                }
              },
              required: ['filePath']
            }
          },
          {
            name: 'analyze_change',
            description: 'Analyzes the impact of changing a specific symbol (function, class, variable) within a file.',
            inputSchema: {
              type: 'object',
              properties: {
                filePath: {
                  type: 'string',
                  description: 'Path to the file'
                },
                symbolName: {
                  type: 'string',
                  description: 'Name of the symbol to analyze'
                }
              },
              required: ['filePath', 'symbolName']
            }
          },
          {
            name: 'explain_connection',
            description: 'Explains why two files are connected (via imports, shared state, events, etc.)',
            inputSchema: {
              type: 'object',
              properties: {
                fileA: {
                  type: 'string',
                  description: 'First file path'
                },
                fileB: {
                  type: 'string',
                  description: 'Second file path'
                }
              },
              required: ['fileA', 'fileB']
            }
          },
          {
            name: 'get_risk_assessment',
            description: 'Returns a risk assessment of the entire project.',
            inputSchema: {
              type: 'object',
              properties: {
                minSeverity: {
                  type: 'string',
                  enum: ['low', 'medium', 'high', 'critical'],
                  description: 'Minimum severity level to include',
                  default: 'medium'
                }
              }
            }
          },
          {
            name: 'search_files',
            description: 'Search for files in the project by pattern.',
            inputSchema: {
              type: 'object',
              properties: {
                pattern: {
                  type: 'string',
                  description: 'Search pattern (supports wildcards like "*Camera*")'
                }
              },
              required: ['pattern']
            }
          },
          {
            name: 'get_server_status',
            description: 'Returns the complete status of the CogniSystem server and orchestrator.',
            inputSchema: {
              type: 'object',
              properties: {}
            }
          }
        ]
      };
    });

    // Handle tool calls
    this.server.setRequestHandler(CallToolRequestSchema, async (request) => {
      const { name, arguments: args } = request.params;

      try {
        let result;

        switch (name) {
          case 'get_impact_map':
            result = await this.handleGetImpactMap(args);
            break;
          case 'analyze_change':
            result = await this.handleAnalyzeChange(args);
            break;
          case 'explain_connection':
            result = await this.handleExplainConnection(args);
            break;
          case 'get_risk_assessment':
            result = await this.handleGetRiskAssessment(args);
            break;
          case 'search_files':
            result = await this.handleSearchFiles(args);
            break;
          case 'get_server_status':
            result = await this.handleGetServerStatus();
            break;
          default:
            throw new McpError(
              ErrorCode.MethodNotFound,
              `Unknown tool: ${name}`
            );
        }

        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify(result, null, 2)
            }
          ]
        };
      } catch (error) {
        console.error(`[Tool Error] ${name}:`, error);
        throw new McpError(
          ErrorCode.InternalError,
          `Tool execution failed: ${error.message}`
        );
      }
    });
  }

  // ============================================================
  // Tool Handlers
  // ============================================================

  async handleGetImpactMap(args) {
    const { filePath } = args;
    console.error(`[Tool] get_impact_map("${filePath}")`);

    // Check if analyzed
    const fileData = await getFileAnalysis(this.projectPath, filePath);
    
    if (!fileData) {
      // Auto-analyze with CRITICAL priority
      console.error(`  â†’ File not analyzed, queueing as CRITICAL`);
      
      try {
        const analysis = await this.orchestrator.analyzeAndWait(filePath, 60000);
        console.error(`  â†’ Analysis completed`);
        
        // Get fresh data after analysis
        return await this.buildImpactMap(filePath);
      } catch (error) {
        return {
          status: 'analyzing',
          message: `File "${filePath}" is being analyzed as CRITICAL priority.`,
          estimatedTime: '30-60 seconds',
          suggestion: 'Please retry this query in a moment.'
        };
      }
    }

    return await this.buildImpactMap(filePath);
  }

  async handleAnalyzeChange(args) {
    const { filePath, symbolName } = args;
    console.error(`[Tool] analyze_change("${filePath}", "${symbolName}")`);

    // Ensure file is analyzed
    let fileData = await getFileAnalysis(this.projectPath, filePath);
    
    if (!fileData) {
      console.error(`  â†’ Auto-analyzing file`);
      await this.orchestrator.analyzeAndWait(filePath, 60000);
      fileData = await getFileAnalysis(this.projectPath, filePath);
    }

    if (!fileData) {
      return {
        error: `Could not analyze ${filePath}`
      };
    }

    const symbol = fileData.exports?.find((e) => e.name === symbolName);

    if (!symbol) {
      return {
        error: `Symbol '${symbolName}' not found in ${filePath}`
      };
    }

    const impactMap = await this.buildImpactMap(filePath);

    return {
      symbol: symbolName,
      file: filePath,
      symbolType: symbol.kind,
      directDependents: impactMap.directlyAffects || [],
      transitiveDependents: impactMap.transitiveAffects || [],
      riskLevel: fileData.riskScore?.severity,
      recommendation:
        fileData.riskScore?.severity === 'critical'
          ? 'âš ï¸ HIGH RISK - This change affects many files'
          : 'âœ“ Safe - Limited scope'
    };
  }

  async handleExplainConnection(args) {
    const { fileA, fileB } = args;
    console.error(`[Tool] explain_connection("${fileA}", "${fileB}")`);

    // Ensure both files are analyzed
    await this.ensureAnalyzed(fileA);
    await this.ensureAnalyzed(fileB);

    const connections = await getAllConnections(this.projectPath);

    const relevant = connections.sharedState
      ?.filter(
        (c) =>
          (c.sourceFile === fileA && c.targetFile === fileB) ||
          (c.sourceFile === fileB && c.targetFile === fileA)
      )
      .slice(0, 5);

    if (!relevant || relevant.length === 0) {
      return {
        fileA,
        fileB,
        connected: false,
        reason: 'No direct connections found'
      };
    }

    return {
      fileA,
      fileB,
      connected: true,
      connections: relevant.map((c) => ({
        type: c.type,
        property: c.globalProperty,
        reason: c.reason,
        severity: c.severity
      }))
    };
  }

  async handleGetRiskAssessment(args) {
    const { minSeverity = 'medium' } = args;
    console.error(`[Tool] get_risk_assessment("${minSeverity}")`);

    const assessment = await getRiskAssessment(this.projectPath);

    const severityOrder = { low: 0, medium: 1, high: 2, critical: 3 };
    const minLevel = severityOrder[minSeverity];

    const filtered = assessment.report.mediumRiskFiles
      ?.concat(assessment.report.highRiskFiles || [])
      .filter((f) => severityOrder[f.severity] >= minLevel)
      .slice(0, 10);

    return {
      summary: assessment.report.summary,
      topRiskFiles: filtered,
      recommendation:
        assessment.report.summary.criticalCount > 0
          ? 'ðŸš¨ Critical issues detected - Review high-risk files'
          : 'âœ“ Risk levels acceptable'
    };
  }

  async handleSearchFiles(args) {
    const { pattern } = args;
    console.error(`[Tool] search_files("${pattern}")`);

    const results = await findFiles(this.projectPath, pattern);
    
    return {
      pattern,
      found: results.length,
      files: results.slice(0, 20)
    };
  }

  async handleGetServerStatus() {
    console.error(`[Tool] get_server_status()`);

    const orchestratorStatus = this.orchestrator.getStatus();
    const metadata = await getProjectMetadata(this.projectPath);

    return {
      initialized: true,
      orchestrator: orchestratorStatus,
      metadata: {
        totalFiles: metadata?.metadata?.totalFiles || 0,
        totalFunctions: metadata?.metadata?.totalFunctions || 0
      },
      cache: this.cache.getCacheStats()
    };
  }

  // ============================================================
  // Helpers
  // ============================================================

  async countProjectFiles() {
    try {
      const { scanProject } = await import('../layer-a-static/scanner.js');
      const files = await scanProject(this.projectPath);
      return files.length;
    } catch (error) {
      console.error('  âš ï¸  Could not count project files:', error.message);
      return 0;
    }
  }

  async hasExistingAnalysis() {
    try {
      const indexPath = path.join(this.projectPath, '.OmnySystemData', 'index.json');
      await fs.access(indexPath);
      return true;
    } catch {
      return false;
    }
  }

  async autoStartLLM() {
    try {
      const aiConfig = await loadAIConfig();

      if (!aiConfig.llm.enabled) {
        console.error('   â„¹ï¸  LLM disabled in config');
        return false;
      }

      const client = new LLMClient(aiConfig);
      const lockFile = path.join(process.env.TEMP || '/tmp', 'omny_brain_gpu.lock');

      // STEP 1: Check if already running (health check)
      console.error('   ðŸ” Checking if LLM server is already running...');
      try {
        const health = await client.healthCheck();
        if (health.gpu || health.cpu) {
          console.error('   âœ“ LLM server already running on port 8000');
          return true;
        }
      } catch {
        // Not running, continue to start
      }

      // Clean lock file if exists (don't wait)
      try { await fs.unlink(lockFile); } catch {}

      // STEP 3: Start LLM server
      console.error('   ðŸš€ Starting LLM server...');
      const omnySystemRoot = path.resolve(path.dirname(fileURLToPath(import.meta.url)), '../..');
      const scriptPath = path.join(omnySystemRoot, 'src/ai/scripts');
      const gpuScript = path.join(scriptPath, 'brain_gpu.bat');
      
      try {
        await fs.access(gpuScript);
      } catch {
        console.error('   âŒ GPU script not found!');
        return false;
      }

      const { spawn } = await import('child_process');
      
      // Create lock file BEFORE spawning to prevent race conditions
      await fs.writeFile(lockFile, `${new Date().toISOString()} - Started by MCP Server`);
      
      // Execute llama-server directly (batch has 'pause' that blocks)
      // Using same params as brain_gpu.bat
      // Use relative paths to avoid emoji issues in absolute paths
      const llamaServer = 'src/ai/server/llama-server.exe';
      const modelPath = 'src/ai/models/LFM2-1.2B-Extract-Q8_0.gguf';
      
      // Debug: Check files exist
      try {
        await fs.access(llamaServer);
        console.error(`   âœ… llama-server.exe found`);
      } catch {
        console.error(`   âŒ llama-server.exe NOT FOUND at: ${llamaServer}`);
        return false;
      }
      
      try {
        await fs.access(modelPath);
        console.error(`   âœ… Model found: LFM2-1.2B-Extract-Q8_0.gguf`);
      } catch {
        console.error(`   âŒ Model NOT FOUND at: ${modelPath}`);
        return false;
      }
      
      const args = [
        '--model', modelPath,
        '--port', '8000',
        '--host', '127.0.0.1',
        '--n-gpu-layers', '999',
        '--ctx-size', '32768',
        '--parallel', '2',
        '-cb',
        '--temp', '0.0',
        '--cache-type-k', 'q8_0',
        '--cache-type-v', 'q8_0',
        '--chat-template', 'chatml'
      ];
      
      console.error('   ðŸš€ Starting llama-server.exe...');
      console.error(`   ðŸ“ CWD: ${omnySystemRoot}`);
      
      // Start LLM in separate terminal window
      // Use start command to open new window
      const command = `start "CogniSystem LLM" cmd /c "${llamaServer} ${args.join(' ')} || pause"`;
      
      const { exec } = await import('child_process');
      exec(command, { cwd: omnySystemRoot });
      
      console.error('   âœ“ GPU server starting in new terminal...');
      console.error('   ðŸ’¡ Window: "CogniSystem LLM"');
      
      child.unref();
      console.error('   âœ“ GPU server starting (port 8000)...');

      // STEP 4: Wait for startup with health check
      console.error('   â³ Waiting for server to initialize...');
      await new Promise(resolve => setTimeout(resolve, 5000));

      let retries = 5;
      while (retries > 0) {
        try {
          const health = await client.healthCheck();
          if (health.gpu || health.cpu) {
            console.error('   âœ… LLM server started successfully');
            return true;
          }
        } catch {
          // Not ready yet
        }
        
        retries--;
        if (retries > 0) {
          console.error(`   â³ Checking... (${5 - retries}/5)`);
          await new Promise(resolve => setTimeout(resolve, 2000));
        }
      }
      
      console.error('   âŒ LLM server failed to start');
      return false;
      
    } catch (error) {
      console.error(`   âŒ LLM auto-start failed: ${error.message}`);
      return false;
    }
  }

  async buildImpactMap(filePath) {
    const deps = await getFileDependencies(this.projectPath, filePath);
    const fileData = await getFileAnalysis(this.projectPath, filePath);

    return {
      file: filePath,
      directlyAffects: deps.usedBy || [],
      transitiveAffects: deps.transitiveDependents || [],
      semanticConnections: fileData?.semanticConnections || [],
      totalAffected:
        (deps.usedBy?.length || 0) +
        (deps.transitiveDependents?.length || 0) +
        (fileData?.semanticConnections?.length || 0),
      riskLevel: fileData?.riskScore?.severity || 'unknown',
      subsystem: fileData?.subsystem
    };
  }

  async ensureAnalyzed(filePath) {
    let fileData = await getFileAnalysis(this.projectPath, filePath);
    
    if (!fileData) {
      console.error(`  â†’ Auto-analyzing: ${filePath}`);
      await this.orchestrator.analyzeAndWait(filePath, 60000);
    }
  }

  /**
   * Run the MCP server
   */
  async run() {
    await this.initialize();

    // Create stdio transport
    this.transport = new StdioServerTransport();
    
    // Connect server to transport
    await this.server.connect(this.transport);
    
    // Keep alive
    console.error('ðŸ’¡ MCP Server running via stdio');
  }

  /**
   * Shutdown gracefully
   */
  async shutdown() {
    console.error('\nðŸ‘‹ Shutting down MCP server...');
    
    await this.orchestrator?.stop();
    
    if (this.transport) {
      await this.transport.close();
    }
    
    console.error('âœ… MCP server stopped');
  }
}

// ============================================================
// CLI Entry Point
// ============================================================

async function main() {
  const projectPath = process.argv[2] || process.cwd();
  const absolutePath = path.resolve(projectPath);

  const mcpServer = new CogniSystemMCPRuntime(absolutePath);

  try {
    await mcpServer.run();
  } catch (error) {
    console.error('Fatal error:', error);
    process.exit(1);
  }
}

main();

