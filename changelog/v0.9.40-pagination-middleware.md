# v0.9.40 - Recursive Pagination Middleware + MCP Tool Fixes

**Date:** 2026-02-20
**Type:** Infrastructure + Quality

## Summary

Sistema de paginación automática **recursiva** implementado como middleware central en el dispatcher MCP. Todas las herramientas obtienen paginación sin ningún cambio individual. Se eliminaron duplicados semánticos en `get_async_analysis`, se conectó `layer-graph/` al sistema activo, y se refactorizaron 2 funciones Grade F.

---

## New: Pagination Middleware (`src/layer-c-memory/mcp/core/pagination.js`)

### Arquitectura
Middleware único en `McpSetupStep.handleToolCall` que intercepta **todas** las respuestas antes de retornarlas:

```
tool handler → rawResult → applyPagination(rawResult, args) → response
```

### Comportamiento recursivo
- **Arrays top-level**: paginados con `offset` + `limit` del caller
- **Arrays anidados** (dentro de objetos/items): capados a `limit`, offset siempre 0
- **Reporting completo**: `_pagination.fields` incluye dot-paths de TODOS los arrays truncados en cualquier nivel (ej: `clusters[].members`, `dataFlow.graph.entryPoints`)
- **SKIP_FIELDS**: campos de control nunca paginados (`summary`, `insights`, `overview`, `error`, etc.)

### Parámetros
```json
{ "offset": 0, "limit": 10 }
```
- `DEFAULT_LIMIT = 10` — balance entre datos ricos y tokens
- `MIN_ARRAY_TO_PAGINATE = 5` — arrays pequeños no se paginan innecesariamente
- `limit` máximo: 500 (para casos donde se quiere todo)

### PAGINATION_SCHEMA
Fragment reutilizable agregado a 9 tools en `tools/index.js`:
`get_impact_map`, `get_risk_assessment`, `get_call_graph`, `get_atom_society`, `detect_patterns`, `get_health_metrics`, `get_async_analysis`, `get_atom_history`, `search_files`

### Ejemplo de _pagination output
```json
"_pagination": {
  "offset": 0,
  "limit": 10,
  "fields": {
    "clusters": { "total": 10, "returned": 10, "hasMore": false },
    "clusters[].members": { "total": 24, "returned": 10, "hasMore": true, "nextOffset": 10 },
    "hubs": { "total": 20, "returned": 10, "hasMore": true, "nextOffset": 10 },
    "dataFlow.graph.entryPoints": { "total": 15, "returned": 10, "hasMore": true, "nextOffset": 10 }
  },
  "usage": "Top-level arrays: use offset/limit. Nested arrays: capped at limit. For item detail use targeted tools."
}
```

---

## Fixed: `get_async_analysis` — Duplicate Issues & Recommendations

### Problema
Cada atom con sequential awaits generaba 2 issues redundantes:
1. `waterfall_awaits` (detectado localmente)
2. `sequential-awaits` (duplicado desde `flowAnalysis.analyses`)

Y 2 recomendaciones idénticas por atom en `recommendations[]`.

### Fix
- `analyzeAsyncIssues`: skip `flowAnalysis.analyses` patterns ya cubiertos por detección local (`sequential-awaits`, `waterfall`, `missing_parallelization`)
- Recomendaciones: deduplicación por `Set(atom.id + recommendation.text)` antes de agregar

---

## Fixed: `get_atom_society` — Token Overflow

### Problema
`insights.biggestCluster` incluía el objeto cluster completo (63 members × campos ricos = 14k chars).

### Fix
`insights` reducido a resumen escueto:
```js
insights: {
  mostConnected: { name, file, callers },
  longestChain: { entry, depth },
  biggestCluster: { size, cohesion, firstMember }
}
```
Arrays completos disponibles en `clusters[]`, `hubs[]`, `orphans[]` con paginación.

---

## Fixed: `detect_patterns` — Token Overflow en `patternType: 'all'`

### Fix
Modo `all` ahora retorna `overview` compacto con top-3/top-5 por categoría.
Cada `patternType` específico retorna datos completos paginados:
```
patternType: "all"         → overview (counts + top items)
patternType: "god-functions" → godFunctions[] paginado (159 total)
patternType: "duplicates"    → exactDuplicates[], similarCode[] paginados
patternType: "fragile-network" → fragile[], wellHandled[]
patternType: "complexity"    → complexityHotspots[]
patternType: "archetype"     → archetypePatterns[]
```

---

## Refactored: `analyzeSingleFile` (Grade F → complexity 20)

**Archivo:** `src/layer-a-static/pipeline/single-file.js`

- Original: 175 LOC, complexity 50, todo en una función
- Refactorizado en 7 helpers: `loadExistingMap`, `resolveFileImports`, `detectConnections`, `saveAtoms`, `buildFileAnalysis`, `saveFileResult`, `printSummary`
- `analyzeSingleFile` complexity: 50 → 20

---

## Connected: `layer-graph/query` → MCP tools

### Problema
`layer-graph/` tenía API completa pero sus funciones de query estaban comentadas en el index. Los MCP tools tenían una copia duplicada de `findCallSites` (204 líneas) en `mcp/tools/lib/analysis/`.

### Fix
1. `layer-graph/query/call-graph-analyzer.js` — reemplazado con implementación canónica (mejor detección de class methods, variable references, importType)
2. `mcp/tools/lib/analysis/call-graph-analyzer.js` — convertido a re-export: `export { findCallSites } from '#layer-graph/query/call-graph-analyzer.js'`
3. `layer-graph/index.js` — habilitados exports de `findCallSites` y `getDependencyGraph`

---

## Eliminated: `loadAllAtoms` duplicado en 3 MCP tools

Los tools `get-health-metrics.js`, `detect-patterns.js`, `get-atom-society.js` tenían cada uno 24 líneas idénticas de `fs.readdir` scanning.

**Fix:** Todos reemplazados con `import { getAllAtoms } from '#layer-c/storage/index.js'`

---

## Stats

| Métrica | Valor |
|---------|-------|
| MCP Tools sin overflow | 19/19 ✅ |
| LOC eliminados (loadAllAtoms duplicado) | ~72 |
| LOC eliminados (call-graph-analyzer duplicado) | ~200 |
| Complexity reducida (analyzeSingleFile) | 50 → 20 |
| Arrays paginados automáticamente | top-level + todos los niveles anidados |
| DEFAULT_LIMIT | 10 items/array |

---

## Navigation Strategy for AI

Con paginación recursiva, el flujo recomendado es:

1. **Primera llamada**: overview general (limit=10)
2. **Ver `_pagination.fields`**: identificar qué arrays tienen `hasMore: true`
3. **Top-level**: paginar con `{ offset: 10, limit: 10 }`
4. **Nested** (ej: `clusters[].members`): usar herramientas específicas sobre el item de interés (`get_function_details`, `get_call_graph`, `get_molecule_summary`)
