# CHANGELOG - OmnySys

## [0.2.0] - 2026-02-01

### Added - Phase 2: Function-Level Tracking (COMPLETE ✓)

#### Core Features
- **Function Extraction**: parser.js now extracts individual functions with metadata
  - Function ID: `FILEID:functionName` format (e.g., `FI:functionA`)
  - Metadata tracked: name, line number, endLine, parameters, isExported flag
  - Call tracking: Detects all direct function calls within each function with line numbers

- **Function Linking**: graph-builder.js creates bidirectional function call graph
  - `function_links` array: Tracks function-to-function calls across files
  - Format: `{ from, to, type, line, file_from, file_to }`
  - Cross-file call resolution using import tracking

- **Enhanced Metadata**:
  - Added `totalFunctions` counter
  - Added `totalFunctionLinks` counter

#### Implementation Details
- **parser.js changes** (288 → 350 lines):
  - Added `functions` array to FileInfo output
  - New helper: `findCallsInFunction()` - traverses function body for CallExpressions
  - New helper: `isExportedFunction()` - checks if function appears in exports
  - New helper: `getFileId()` - generates unique file prefix for IDs

- **graph-builder.js changes** (334 → 410 lines):
  - New `functions` key in systemMap (maps file → functions array)
  - New `function_links` array (all function-to-function calls)
  - New helper: `findFunctionInResolution()` - resolves function calls across import boundaries
  - New helper: `countTotalFunctions()` - calculates total function count

#### Test Results
- **scenario-1-simple-import validation**: ✓ PASS
  - Extracted functions: 5 (functionA, displayConstant, functionB, getConstant, functionC)
  - Function links detected: 3
  - Cross-file resolution: ✓ All calls correctly matched
  - Line numbers: ✓ Accurate (file A calls file B at line 9, etc.)

#### Output Example
```json
{
  "functions": {
    "src/fileA.js": [
      {
        "id": "FI:functionA",
        "name": "functionA",
        "line": 8,
        "endLine": 11,
        "params": ["value"],
        "isExported": true,
        "calls": [
          { "name": "functionB", "type": "direct_call", "line": 9 }
        ]
      }
    ]
  },
  "function_links": [
    {
      "from": "FI:functionA",
      "to": "FI:functionB",
      "type": "call",
      "line": 9,
      "file_from": "src/fileA.js",
      "file_to": "src/fileB.js"
    }
  ]
}
```

#### Backward Compatibility
- ✓ File-level graph still intact
- ✓ All existing metadata preserved
- ✓ Dependencies array unchanged
- ✓ Purely additive: function tracking is new feature layer

#### Next Steps
- **Phase 2.5**: AI Editor Integration using function-level graph
  - Query: "What functions depend on this?"
  - Query: "What's the impact of editing this function?"
  - Utilize function_links for impact analysis

---

## [0.1.0] - 2026-01-31

### Added - Phase 1: Layer A - Static Analysis (COMPLETE ✓)

#### Core Components

1. **scanner.js** (156 lines)
   - Discovers all project files matching supported extensions
   - Handles TypeScript, JSX, and standard JS files
   - Returns project-relative paths with forward slashes (Windows compatible)
   - Excludes node_modules, .git, dist, build, etc.

2. **parser.js** (232 lines)
   - Parses individual files using @babel/parser AST generation
   - Extracts:
     - **Imports**: ES6 modules and CommonJS requires with source info
     - **Exports**: Named, default, and declaration exports
     - **Definitions**: Function and class declarations
     - **Calls**: All function calls at file level
   - Handles JSX, TypeScript, Flow, async/await, optional chaining, etc.

3. **resolver.js** (254 lines)
   - Converts relative imports to project-relative absolute paths
   - Features:
     - Relative path resolution (`./utils` → `src/utils.js`)
     - Alias resolution (tsconfig.json / jsconfig.json support)
     - External module detection (node_modules, npm packages)
     - File extension resolution (`.js`, `.ts`, `.tsx`, `.jsx`, etc.)
     - Index file detection (`import from './dir'` → `./dir/index.js`)
   - Returns standardized `{ resolved, type, reason }` format

4. **graph-builder.js** (334 lines)
   - Constructs complete dependency graph from parsed files
   - Builds bidirectional relationships:
     - `dependsOn`: Files this file imports from
     - `usedBy`: Files that import this file
     - `transitiveDepends`: All indirect dependencies (recursive)
     - `transitiveDependents`: All files affected by this file
   - Features:
     - Circular dependency detection via DFS traversal
     - Transitive dependency calculation
     - Risk level calculation based on affected files
     - Impact assessment via `getImpactMap()` function

5. **indexer.js** (192 lines)
   - Orchestrates complete Layer A pipeline
   - 8-step process:
     1. Project detection (TypeScript/JavaScript)
     2. File scanning
     3. File parsing with AST
     4. Import resolution configuration
     5. Import resolution execution
     6. Path normalization (critical fix)
     7. Dependency graph construction
     8. Output serialization to JSON
   - CLI interface: `node src/layer-a-static/indexer.js /path/to/project [output-file]`

#### Key Features

- **Complete Dependency Analysis**
  - File-level import tracking
  - Symbol-level import tracking (what's imported, not just module)
  - Bidirectional graph (dependencies and dependents)
  - Transitive dependency calculation

- **Error Handling**
  - Graceful parsing errors (continues on syntax errors)
  - Unresolved import tracking
  - Path escape detection (imports outside project)

- **Output Format**
  - Standardized JSON system map
  - Normalized paths (project-relative, forward slashes)
  - Rich metadata about graph (file count, dependency count, cycles)

#### Path Normalization (Critical Architecture Decision)

The entire system normalizes to **project-relative, forward-slash paths**:
- Scanner returns: `src/fileA.js` (not absolute Windows paths)
- Parser stores: Keys as absolute, values as-is
- Resolver returns: Project-relative paths via `normalizeToProjectRelative()`
- Indexer Paso 6: Converts all keys to project-relative before graph-builder
- Graph-builder expects: All keys already project-relative

This ensures consistent graph construction across Windows/Unix systems.

#### Test Validation

**scenario-1-simple-import** (3 files: A→B→C)
- ✓ 3 files detected
- ✓ 2 direct dependencies found (A→B, B→C)
- ✓ Transitive dependencies correct (A depends on B and C transitively)
- ✓ Circular dependency detection: none detected ✓

#### Bug Fixes

1. **CLI Detection** (parser.js, scanner.js, indexer.js)
   - Issue: `import.meta.url` not reliable for ESM module detection
   - Fix: Changed to `process.argv[1].includes('filename.js')`

2. **Path Normalization** (resolver.js)
   - Issue: Resolver returning absolute Windows paths vs scanner's relative paths
   - Fix: Added `normalizeToProjectRelative()` function to ensure consistency

3. **Graph Construction** (indexer.js Paso 6)
   - Issue: 0 dependencies despite successful import resolution
   - Fix: Added path normalization step before graph-builder to ensure all paths match

#### Architecture Decisions

- **Babel for AST**: Chose Babel over alternatives for maximum JavaScript variant support
- **File-level first**: Start with file-level analysis before function-level (Phase 2)
- **JSON for storage**: Start with JSON, plan SQLite for Phase 3, vectorial DB later
- **Project-relative paths**: Consistent, portable, easy to understand

#### Future Phases

- **Phase 2**: Function-level tracking (currently in progress)
- **Phase 2.5**: AI Editor integration using function-level graph
- **Phase 3**: MCP Server (Model Context Protocol) for AI integration
- **Phase 4**: Semantic analysis (non-obvious dependencies, patterns)

#### Documentation

- README.md: User guide and quick start
- PHASE-2-PLAN.md: Detailed implementation plan for function-level tracking
- ARCHITECTURE.md: System design and component interaction

---

## [0.0.0] - Initial Setup

- Project initialization
- Dependency installation (@babel/parser, @babel/traverse, fast-glob)
- Git repository setup
- GitHub remote configuration