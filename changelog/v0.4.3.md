# CHANGELOG - OmnySys v0.4.3

## [0.4.3] - 2026-02-03

### üéØ RESUMEN EJECUTIVO

Versi√≥n **PATCH**: Correcci√≥n de bugs cr√≠ticos y mejoras de estabilidad del sistema.

- üîó **Batch Processor Conectado**: Fix del flujo FileWatcher ‚Üí Queue ‚Üí Worker
- üíæ **State Manager At√≥mico**: Escritura at√≥mica para prevenir corrupci√≥n de estado
- üß† **Cache LRU**: L√≠mites de memoria para QueryCache y LLMCache
- üßπ **MCP Cleanup**: Limpieza de recursos al cerrar servidor
- üîÑ **Rollback de An√°lisis**: Restauraci√≥n autom√°tica si el an√°lisis falla
- üéØ **LLM Unificado**: Comportamiento consistente entre comandos

---

## üêõ BUGS CORREGIDOS

### P0: Batch Processor Dead End

**Problema**: El BatchProcessor recib√≠a cambios del FileWatcher pero no los enviaba a la AnalysisQueue.

**Archivo**: `src/core/unified-server.js`

**Fix**:
```javascript
// Nuevo callback processChange conecta a la queue
this.batchProcessor = new BatchProcessor({
  processChange: async (change) => {
    const priority = this.calculateChangePriority(change);
    this.queue.enqueue(change.filePath, priority);
    // Notifica a WebSocket clients
  }
});
```

**Flujo corregido**:
```
File Watcher ‚Üí BatchProcessor ‚Üí AnalysisQueue ‚Üí AnalysisWorker ‚Üí indexProject
                    ‚Üì
              WebSocket notify
```

---

### P0: State Manager Race Condition

**Problema**: `fs.writeFile` no es at√≥mico; requests simult√°neos pod√≠an corromper el estado.

**Archivo**: `src/core/state-manager.js`

**Fix**:
```javascript
// Escritura at√≥mica (write temp ‚Üí rename)
async write(state) {
  return this.writeLock = this.writeLock.then(async () => {
    const tempPath = `${this.filePath}.tmp.${Date.now()}.${process.pid}`;
    await fs.writeFile(tempPath, JSON.stringify(state, null, 2));
    await fs.rename(tempPath, this.filePath); // At√≥mico
  });
}
```

**Beneficio**: Estado consistente incluso con m√∫ltiples requests simult√°neos.

---

### P0: QueryCache Sin L√≠mite

**Problema**: El cache en RAM crec√≠a indefinidamente. Proyectos grandes pod√≠an causar OutOfMemory.

**Archivo**: `src/layer-c-memory/query-cache.js`

**Fix**:
```javascript
// L√≠mite de 1000 entradas con LRU eviction
constructor(ttlMinutes = 5, maxEntries = 1000) {
  this.cache = new Map();
  this.maxEntries = maxEntries;
}

set(key, data) {
  // LRU: eliminar entrada m√°s antigua si se alcanza el l√≠mite
  if (this.cache.size >= this.maxEntries) {
    const oldestKey = this.cache.keys().next().value;
    this.cache.delete(oldestKey);
    this.stats.evictions++;
  }
  // ...
}
```

---

### P0: LLMCache Sin Rotaci√≥n

**Problema**: Cada cambio de c√≥digo generaba una nueva entrada de cache. Sin l√≠mite, pod√≠a llenar el disco.

**Archivo**: `src/layer-b-semantic/llm-cache.js`

**Fix**:
```javascript
// Rotaci√≥n FIFO (mantiene 500 entradas m√°ximo)
constructor(cacheDir = '.OmnySystemData/llm-cache', maxEntries = 500) {
  this.maxEntries = maxEntries;
}

async rotateCacheIfNeeded() {
  // Elimina los archivos m√°s antiguos si excede el l√≠mite
  // Mantiene el 80% m√°s reciente
}
```

---

### P0: MCP Server Memory Leak

**Problema**: `setInterval` sin cleanup. El proceso no pod√≠a terminar gracefulmente.

**Archivo**: `src/layer-c-memory/mcp-server.js`

**Fix**:
```javascript
constructor() {
  this.statsInterval = null; // Track del interval
}

// Cleanup en SIGINT
process.on('SIGINT', () => {
  if (server.statsInterval) clearInterval(server.statsInterval);
});

// M√©todo stop() para cleanup program√°tico
async stop() {
  if (this.statsInterval) clearInterval(this.statsInterval);
}
```

---

### P1: WebSocket Subscriptions Memory Leak

**Problema**: El Set `subscriptions` no se limpiaba al cerrar conexiones.

**Archivo**: `src/core/websocket/websocket-manager.js`

**Fix**:
```javascript
handleClose() {
  const subCount = this.subscriptions.size;
  this.subscriptions.clear(); // Limpieza expl√≠cita
  this.manager.removeClient(this.id);
}
```

---

### P1: Comportamiento LLM Inconsistente

**Problema**: `consolidate()` fallaba sin LLM, pero `serve()` intentaba iniciarlo autom√°ticamente.

**Archivo**: `omnysystem.js`

**Fix**:
```javascript
// Nueva funci√≥n unificada
async function ensureLLMAvailable(aiConfig, options = {}) {
  const { required = true, autoStart = true, maxWaitSeconds = 60 } = options;
  // ... intenta iniciar, espera, o falla seg√∫n configuraci√≥n
}

// Uso en ambos comandos:
const llmStatus = await ensureLLMAvailable(aiConfig, { 
  required: true, 
  autoStart: true 
});
```

---

### P1: Rollback de An√°lisis Fallido

**Problema**: Si el an√°lisis fallaba, el sistema pod√≠a quedar con datos parciales/corruptos.

**Archivo**: `src/core/analysis-worker.js`

**Fix**:
```javascript
async analyze(job) {
  // Guardar an√°lisis anterior
  const previousAnalysis = await getFileAnalysis(this.rootPath, job.filePath);
  
  try {
    await indexProject(...);
  } catch (error) {
    // Rollback: restaurar an√°lisis anterior
    if (previousAnalysis) {
      await saveFileAnalysis(this.rootPath, job.filePath, previousAnalysis);
    }
    throw error;
  }
}
```

---

## üÜï NUEVO: Sistema de Cach√© Unificado e Inteligente

### El Problema
El sistema anterior ten√≠a **tres caches separados** que no se coordinaban:
1. **AnalysisCache** (est√°tico) - `cache.json`
2. **LLMCache** (IA) - `llm-cache/`
3. **QueryCache** (RAM) - en memoria

**Problemas:**
- Si cambiaba un archivo, solo se invalidaba el cache est√°tico, pero el LLMCache pod√≠a quedar con datos inconsistentes
- Si borr√°bamos el LLMCache por rotaci√≥n, pod√≠amos llamar a la IA innecesariamente para archivos que no cambiaron
- No hab√≠a invalidaci√≥n en cascada: si A depende de B y B cambia, A no se re-analizaba autom√°ticamente

### La Soluci√≥n

**Archivos nuevos:**
- `src/core/unified-cache-manager.js` - Gestor de cach√© unificado
- `src/core/cache-integration.js` - Integraci√≥n con el sistema de an√°lisis

**Caracter√≠sticas:**

#### 1. Detecci√≥n Inteligente de Cambios
```javascript
// Tipos de cambios detectados:
ChangeType.NONE      // Sin cambios (cache hit)
ChangeType.COSMETIC  // Solo formato/comentarios (no requiere re-an√°lisis)
ChangeType.STATIC    // Cambios en imports/exports (re-an√°lisis est√°tico)
ChangeType.SEMANTIC  // Cambios en localStorage/events (re-an√°lisis completo)
ChangeType.CRITICAL  // Cambios breaking (invalida dependientes)
```

#### 2. Coordinaci√≥n Est√°tico + LLM
- Si el archivo NO cambi√≥ ‚Üí Usa ambos caches (est√°tico + LLM)
- Si cambi√≥ COSM√âTICAMENTE ‚Üí Solo actualiza est√°tico, mantiene insights LLM
- Si cambi√≥ SEM√ÅNTICAMENTE ‚Üí Re-analiza TODO (est√°tico + LLM)
- Si es CR√çTICO ‚Üí Re-analiza TODO + invalida archivos dependientes

#### 3. Invalidaci√≥n en Cascada
```javascript
// Si Button.js cambia cr√≠ticamente:
// - Se invalida Button.js
// - Se invalidan todos los archivos que importan Button.js
// - Se invalidan recursivamente los que dependen de esos archivos
```

#### 4. Estructura del Cach√© Unificado
```
.OmnySystemData/unified-cache/
‚îú‚îÄ‚îÄ cache-index.json           # √çndice maestro con versiones y dependencias
‚îú‚îÄ‚îÄ static/
‚îÇ   ‚îî‚îÄ‚îÄ src_components_Button.js.v1.json    # An√°lisis est√°tico v1
‚îÇ   ‚îî‚îÄ‚îÄ src_components_Button.js.v2.json    # An√°lisis est√°tico v2 (si cambi√≥)
‚îú‚îÄ‚îÄ llm/
‚îÇ   ‚îî‚îÄ‚îÄ src_components_Button.js.v1.insights.json  # Insights LLM v1
‚îÇ   ‚îî‚îÄ‚îÄ src_components_Button.js.v2.insights.json  # Insights LLM v2
```

**Cada versi√≥n est√° coordinada:** La v2 del an√°lisis est√°tico va con la v2 de los insights LLM.

### Ejemplo de Flujo

```javascript
// Escenario 1: Agregas un comentario a Button.js
1. Se detecta cambio COSM√âTICO
2. Se actualiza an√°lisis est√°tico (para estar al d√≠a)
3. NO se llama al LLM (insights siguen v√°lidos)
4. Se guarda nueva versi√≥n: v2 (est√°tico), v1 se mantiene (LLM)

// Escenario 2: Agregas localStorage a Button.js
1. Se detecta cambio SEM√ÅNTICO
2. Se re-analiza est√°tico (detecta localStorage nuevo)
3. SE LLAMA AL LLM (puede haber nuevas conexiones)
4. Se guarda nueva versi√≥n: v2 (est√°tico + LLM)

// Escenario 3: Cambias exports de Button.js
1. Se detecta cambio CR√çTICO
2. Se re-analiza TODO
3. Se invalidan todos los archivos que importan Button.js
4. Esos archivos tambi√©n se re-analizar√°n en su momento
```

### Beneficios

| Antes | Despu√©s |
|-------|---------|
| 3 caches no coordinados | 1 sistema unificado |
| Invalidaci√≥n manual | Invalidaci√≥n autom√°tica e inteligente |
| Riesgo de inconsistencias | Consistencia garantizada |
| LLM llamado innecesariamente | LLM solo cuando realmente cambia algo relevante |
| Sin tracking de dependencias | Grafo de dependencias actualizado autom√°ticamente |

---

## üìä RESUMEN DE CAMBIOS

### Fixes Originales

| Archivo | Cambios | Descripci√≥n |
|---------|---------|-------------|
| `omnysystem.js` | +175/-54 | Funci√≥n `ensureLLMAvailable()` unificada |
| `src/core/unified-server.js` | +255/-35 | BatchProcessor conectado a Queue |
| `src/core/state-manager.js` | +63/-17 | Escritura at√≥mica con lock |
| `src/core/analysis-worker.js` | +25/-0 | Rollback en caso de fallo |
| `src/core/websocket/websocket-manager.js` | +10/-1 | Cleanup de subscriptions |
| `src/layer-c-memory/query-cache.js` | +21/-4 | LRU eviction (max 1000 entries) |
| `src/layer-b-semantic/llm-cache.js` | +46/-3 | Rotaci√≥n FIFO (max 500 entries) |
| `src/layer-c-memory/mcp-server.js` | +27/-2 | Cleanup de intervals |
| `src/layer-a-static/indexer.js` | +5/-2 | Par√°metro skipLLM propagado |
| `src/layer-a-static/scanner.js` | +2/-1 | Fix menor |
| `src/core/file-watcher.js` | +3/-1 | Fix menor |

### NUEVO: Sistema de Cach√© Unificado

| Archivo | L√≠neas | Descripci√≥n |
|---------|--------|-------------|
| `src/core/unified-cache-manager.js` | +390 | Sistema de cach√© coordinado (NUEVO) |
| `src/core/cache-integration.js` | +165 | Integraci√≥n con indexer (NUEVO) |
| `src/layer-a-static/indexer.js` | +5 | Integraci√≥n con UnifiedCacheManager |

**Total**: +1083 l√≠neas, -104 l√≠neas, 13 archivos modificados

---

## üß™ VALIDACI√ìN

```bash
# Todos los archivos pasan validaci√≥n sint√°ctica ‚úÖ
node --check src/core/unified-server.js
node --check src/core/state-manager.js
node --check src/core/analysis-worker.js
node --check src/core/websocket/websocket-manager.js
node --check src/layer-c-memory/query-cache.js
node --check src/layer-b-semantic/llm-cache.js
node --check src/layer-c-memory/mcp-server.js
node --check omnysystem.js
```

---

## üó∫Ô∏è ROADMAP ACTUALIZADO

### v0.4.3 (Actual) ‚úÖ
- [x] Batch Processor conectado a Queue
- [x] State Manager at√≥mico
- [x] Cache LRU con l√≠mites
- [x] MCP cleanup
- [x] Rollback de an√°lisis
- [x] LLM behavior unificado

### v0.5.0 (Pr√≥ximo)
- [ ] Completar CSS-in-JS (emotion, theme-ui)
- [ ] Completar TypeScript (generics, type guards)
- [ ] Completar Redux/Context (providers, consumers)
- [ ] Activar Opci√≥n C: an√°lisis por funci√≥n

---

**Fin del changelog v0.4.3**
