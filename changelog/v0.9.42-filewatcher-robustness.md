# v0.9.42 - FileWatcher Pipeline Robustness

## Resumen

Auditoría completa del pipeline de edición (FileWatcher). Se detectaron y corrigieron 4 bugs
silenciosos que afectaban la integridad del storage de atoms y la eficiencia del sistema.

## Bugs corregidos

### Bug 1 — Pipeline 1 sin lineage tracking (`analyze.js`) — CRÍTICO

**Problema:** El FileWatcher (Pipeline 1) no tenía el fix de lineage tracking implementado en v0.9.41
para Pipeline 2 (CLI/indexer). Al editar un archivo y borrar una función, `analyzeFile()` guardaba
los nuevos atoms sin verificar cuáles desaparecieron → atoms huérfanos (stale data) sin marcar.

**Fix:** `analyze.js::analyzeFile()` ahora carga atoms previos con `loadAtoms()` antes de guardar
los nuevos, detecta funciones removidas y las marca con `lineage.status = 'removed'` vía
`_markAtomAsRemoved()`. Ambos pipelines tienen comportamiento consistente.

### Bug 2 — Path format incorrecto en `getAtomsForFile` (`handlers.js`) — CRÍTICO

**Problema:** `handlers.js::getAtomsForFile()` buscaba atoms en:
```
.omnysysdata/atoms/src_layer-a_file_js/   (flat, legacy)
```
Pero `storage/atoms/atom.js::saveAtom()` los guarda en:
```
.omnysysdata/atoms/src/layer-a/file/fn.json   (nested, actual)
```
Resultado: `createShadowsForFile()` y `enrichAtomsWithAncestry()` recibían **siempre 0 atoms**
— el sistema de sombras/ancestry nunca funcionó correctamente.

**Fix:** `getAtomsForFile()` ahora delega a `loadAtoms()` de la capa de storage.

### Bug 3 — `removeAtomMetadata` borraba el path incorrecto (`handlers.js`) — CRÍTICO

**Problema:** Mismo error de path que Bug 2. Cuando se borraba un archivo, `removeAtomMetadata()`
intentaba borrar `.omnysysdata/atoms/src_layer-a_file_js/` (que no existe). Los atoms del
archivo eliminado nunca se borraban → acumulación de stale data silenciosa.

**Fix:** `removeAtomMetadata()` ahora calcula el path correcto:
```js
path.join(atomsDir, path.dirname(filePath), path.basename(filePath, ext))
```

### Bug 4 — `saveAtom` en handlers escribía en el path incorrecto (`handlers.js`) — MEDIO

**Problema:** `handlers.js::saveAtom()` (usado por `enrichAtomsWithAncestry`) escribía atoms
enriquecidos en el path flat legacy → duplicados en el storage incorrecto, sin ser leídos
por ninguna otra parte del sistema.

**Fix:** `saveAtom()` en handlers delega a `saveAtomToStorage()` de la capa de storage.

### Bug 5 — Sin hash-dedup en `handleFileModified` (`handlers.js`) — MENOR (eficiencia)

**Problema:** Cada evento de modificación de archivo disparaba re-análisis completo incluso si
el contenido no había cambiado. Los OS generan múltiples eventos `change` por un solo guardado.

**Fix:** `handleFileModified()` calcula el hash MD5 del nuevo contenido y lo compara contra
`this.fileHashes`. Si es idéntico → skip con debug log. Si cambió → actualiza el hash y re-analiza.

## Archivos modificados

### `src/core/file-watcher/analyze.js`
- Import de `loadAtoms` desde `#layer-c/storage`
- `analyzeFile()`: carga atoms previos, detecta removidos, llama `_markAtomAsRemoved()`
- Nueva función `_markAtomAsRemoved(atom)` — misma lógica que `single-file.js`

### `src/core/file-watcher/handlers.js`
- Import de `loadAtoms` y `saveAtom as saveAtomToStorage` desde `#layer-c/storage`
- `getAtomsForFile()`: delega a `loadAtoms(this.rootPath, filePath)`
- `saveAtom()`: delega a `saveAtomToStorage(this.rootPath, filePath, atom.name, atom)`
- `removeAtomMetadata()`: usa path nested correcto
- `handleFileModified()`: hash-dedup antes de re-analizar

## Estado del sistema post-fix

| Subsistema | Antes | Después |
|---|---|---|
| Lineage tracking (FileWatcher) | ❌ Sin tracking | ✅ Igual que CLI |
| Shadow registry | ❌ 0 atoms siempre | ✅ Lee atoms reales |
| Ancestry enrichment | ❌ 0 atoms siempre | ✅ Funciona |
| Cleanup al borrar archivo | ❌ Atoms nunca borrados | ✅ Borrado correcto |
| Re-análisis innecesarios | ❌ Siempre re-analiza | ✅ Skip si no cambió |
