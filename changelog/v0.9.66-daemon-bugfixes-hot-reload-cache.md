# v0.9.66 - Daemon Bug Fixes: Hot-Reload Cache, Phantom Terminals & Queue

**Date:** 2026-02-26

Esta versiÃ³n resuelve cuatro bugs crÃ­ticos que afectaban la estabilidad del daemon MCP y la experiencia de desarrollo en Windows. El mÃ¡s importante: el sistema de hot-reload ya no usa mÃ³dulos cacheados por Node.js â€” cada cambio en un tool es efectivamente propagado al registry de handlers en caliente.

---

## ğŸ› Bugs Corregidos

### 1. Hot-Reload ESM Cache Invalidation â€” `mcp-http-server.js`, `tool-strategy.js`, `restart-server.js`

**Problema:** Los cambios en tools (ej. `code-generator.js`) no se reflejaban despuÃ©s de un hot-reload ni de un `restart_server`. El MCP seguÃ­a usando la versiÃ³n cacheada en memoria.

**Causa raÃ­z:** `toolHandlers` era un `import` estÃ¡tico en `mcp-http-server.js`. Una vez que el proceso arrancaba, la referencia quedaba congelada. El `ToolStrategy` solo re-importaba el archivo cambiado (con `?bust=timestamp` para el cache de ESM), pero nunca actualizaba el map de handlers que las peticiones MCP realmente usaban.

**Fix (3 archivos quirÃºrgicos):**
- **`mcp-http-server.js`**: `toolHandlers` â†’ registry mutable (`toolRegistry`). Nueva funciÃ³n `refreshToolRegistry()` que re-importa `tools/index.js` completo con cache-busting y actualiza el map en caliente. Expuesta como export para que otros mÃ³dulos la puedan llamar.
- **`tool-strategy.js`**: DespuÃ©s de re-importar el archivo cambiado, llama `refreshToolRegistry()` vÃ­a dynamic import. AsÃ­ la cadena completa se propaga, no solo el archivo hoja.
- **`restart-server.js`**: El fallback de component-restart ahora llama `refreshToolRegistry()` al finalizar la pipeline de re-inicializaciÃ³n.

**Flujo despuÃ©s del fix:**
```
Cambio en archivo â†’ FileWatcher â†’ ToolStrategy.reload(file)
  â†’ import(file?bust=ts)         â† archivo hoja con cache limpio
  â†’ refreshToolRegistry()        â† toda la cadena de tools/index.js
    â†’ toolRegistry.handlers = {} â† map de handlers actualizado
  â†’ prÃ³xima llamada MCP usa el cÃ³digo nuevo âœ…
```

---

### 2. `this.queue.findPosition is not a function` â€” `analysis-queue.js`

**Problema:** `TypeError: this.queue.findPosition is not a function` al llamar cualquier herramienta con `autoAnalyzeMissing=true`.

**Causa raÃ­z:** `analyzeAndWait()` en `queueing.js` llama `this.queue.findPosition(filePath)`, pero `AnalysisQueue` solo tenÃ­a `getPosition()` â€” `findPosition` no existÃ­a.

**Fix:** AÃ±adido `findPosition()` como alias de `getPosition()` en `AnalysisQueue`. Un alias de una lÃ­nea â€” ambos tienen la misma semÃ¡ntica (retorna -1 si no en cola, â‰¥0 si estÃ¡).

---

### 3. Ventanas de Consola Fantasma en Windows â€” MÃºltiples Archivos

**Problema:** En Windows, cada acciÃ³n del daemon (llamadas MCP, hot-reload, ediciÃ³n con `atomic_edit`) abrÃ­a brevemente una ventana de terminal visible en VSCode. Muy disruptivo para el usuario.

**Causa raÃ­z primaria: `syntax-validator.js`**
```js
// ANTES â€” string con && fuerza cmd.exe /c â†’ terminal visible
execSync(`chcp 65001 >nul && node --check "${tmpFile}"`, { windowsHide: true })

// DESPUÃ‰S â€” spawn directo sin intermediario cmd.exe
spawnSync(process.execPath, ['--check', tmpFile], { windowsHide: true })
```
`execSync` con una string que contiene `&&` obliga a Windows a abrir `cmd.exe /c` como intermediario. Aunque `windowsHide: true` estÃ© seteado, VSCode lo registra como un nuevo terminal integrado. La soluciÃ³n es `spawnSync` con `process.execPath` directamente.

**Causas adicionales corregidas** (faltaba `windowsHide: true`):

| Archivo | Operaciones |
|---------|------------|
| `get-atom-history.js` | 5Ã— `git log`, `git show`, `git blame` |
| `server-class.js` | `taskkill /F /IM llama-server.exe` (en cada restart) |
| `process-manager.js` | `netstat`, `taskkill /F /PID`, `wmic process` |
| `llm.js` | `wmic process` (check brain_gpu), `netstat` |
| `ai.js` | `taskkill /F /IM llama-server.exe`, 2Ã— `spawn cmd.exe` |

---

### 4. Depth-Aware Import Paths en Tests Generados â€” `code-generator.js`, `batch-generator.js`

**Problema:** Los tests generados para `src/audit/checks/` usaban `../../src/audit/` (profundidad fija 2), cuando la ruta correcta desde `tests/generated/audit/checks/` es `../../../../src/audit/` (profundidad 4).

**Causa raÃ­z:** `resolveImportAlias()` en `test-utils.js` tenÃ­a hardcodeado `../../` para rutas no-aliased.

**Fix:** `resolveImportAlias(filePath, outputPath)` ahora computa la profundidad desde `outputPath` para generar la cantidad correcta de `../` en el import. `batch-generator.js` pasa `path.dirname(testFilePath)` como `outputPath`.

---

## ğŸ§  Nuevo: Capa SemÃ¡ntica para Tests â€” `atom-semantic-analyzer/`

Nueva capa de anÃ¡lisis semÃ¡ntico para la generaciÃ³n de tests:

```
generate-tests/atom-semantic-analyzer/
  index.js      â†’ API pÃºblica (registro de lenguajes, getAssertionForAtom)
  core.js       â†’ AtomSemantics type + buildAssertionFromSemantics()
  js-analyzer.js â†’ ImplementaciÃ³n JS/TS: detecciÃ³n void, literales de retorno,
                   mutaciÃ³n de parÃ¡metros, contexto this, paramHints
```

**Mejoras de calidad en tests generados:**
- Funciones void â†’ `expect(() => fn()).not.toThrow()` en vez de `expect(result).toBeDefined()`
- Funciones void+mutation â†’ cuerpo con spy `vi.fn()` en objetos equipados
- Literales de retorno reales (ej. `'HEALTHY'`, `'CRITICAL'`) â†’ aserciones de igualdad exacta

**Extensible por diseÃ±o:** Para agregar un nuevo lenguaje, solo se crea `py-analyzer.js` y se registra en `ANALYZER_REGISTRY` en `index.js`. Sin cambios en el resto del sistema.

---

## ğŸ“Š Impacto

| MÃ©trica | Antes | DespuÃ©s |
|---------|-------|---------|
| Hot-reload efectivo | âŒ MÃ³dulos cacheados | âœ… Cache invalidado |
| Ventanas fantasma (Windows) | âœ…â†’âŒ AparecÃ­an siempre | âœ… Eliminadas |
| `findPosition` error | âŒ TypeError en cada autoAnalyze | âœ… Resuelto |
| Import paths en tests | âŒ Profundidad fija (../../) | âœ… Depth-aware dinÃ¡mico |

## ğŸ”œ Pendiente

- Verificar hot-reload end-to-end con regeneraciÃ³n batch de tests
- Investigar `this.queue.findPosition is not a function` en otras rutas de cÃ³digo similares
- Regenerar tests existentes con paths corregidos (actualmente tienen `../../` hardcodeado de iteraciones previas)
