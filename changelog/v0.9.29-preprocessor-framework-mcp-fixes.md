# v0.9.29 — Preprocessor Framework + Import Cleanup + MCP Stability (2026-02-19)

## Resumen

Esta versión consolida dos bloques de trabajo:

1. **Import Cleanup (v0.9.20–v0.9.28):** Eliminación completa de wrappers deprecated y corrección de todas las importaciones rotas tras el refactor. 0 broken imports en 1152 archivos verificados.
2. **Preprocessor Framework (nuevo):** Sistema extensible de preprocesamiento léxico para resolver ambigüedades de sintaxis ANTES del parseo, con 49 tests.
3. **MCP Stability:** Log de sesión limpiado al arranque + bug documentado en `analyze_signature_change` para class-methods.

---

## Bloque 1 — Import Cleanup (v0.9.20–v0.9.28)

### Contexto

Tras eliminar los wrappers deprecated en v0.9.22–v0.9.23, varios archivos quedaron con imports rotos apuntando a rutas eliminadas. Se realizó un audit sistemático hasta lograr 0 broken imports.

### v0.9.20 — Revert `pipelineOperator` del parser genérico

**4 archivos modificados**

Bug introducido en v0.9.19: agregar `pipelineOperator` con Hack proposal al parser genérico hacía que archivos con shebangs (`#!/usr/bin/env node`) fallaran con `'Topic reference is unbound'` porque Babel interpretaba `#` del shebang como topic reference.

- Eliminado `pipelineOperator` de `parser/config.js`, `extractors/atomic/index.js`, `event-detector/constants.js`
- Tests actualizados para verificar manejo correcto de shebangs

---

### v0.9.21 — `allowHashBang: true` + remove `pipelineOperator` de data-flow

**3 archivos modificados**

Bug 1: `omnysystem.js` seguía fallando con `Unexpected token (1:1)` en el shebang.
Fix: `allowHashBang: true` añadido a `parser/config.js` y `data-flow/index.js`.

Bug 2: 100+ `Data flow extraction failed: this.input.charCodeAt is not a function` en logs.
Causa raíz: `pipelineOperator` con `topicToken: '#'` conflictúa con shebangs Y private fields — Babel confundía `#field` con topic reference.
Fix: Eliminado `pipelineOperator` de `data-flow/index.js` PARSER_OPTIONS definitivamente.

---

### v0.9.22 — Eliminación masiva de wrappers deprecated

**95 archivos modificados — 687 inserciones, 1483 eliminaciones**

El cambio más grande del ciclo. Se eliminaron **25 archivos wrapper deprecated** de re-export (zero-caller o ya migrados) y se migraron 30+ callers a las rutas reales.

Wrappers eliminados:
- `services/llm-service.js` → migraron 8 callers a `llm-service/index.js`
- `ai/llm/client.js` → migraron 2 callers a `client/index.js`
- `shared/derivation-engine.js` → migraron 3 callers a `derivation-engine/index.js`
- `query/queries/file-query.js` → migraron 4 callers
- `layer-c-memory/mcp/core/hot-reload-manager.js` → migrado `server-class.js`
- `validation/core/validation-engine.js`, `validation-result.js`, `rule-registry.js`
- `layer-b-semantic/llm-response-validator.js`, `metadata-contract.js`, `metadata-extractors.js`, `pattern-matchers.js`, `project-structure-analyzer.js`
- `shadow-registry/lineage-tracker.js`, `lineage-validator.js`
- `verification/validators/consistency-validator.js`, `integrity-validator.js`
- `pipeline/analyses/V2_ALGORITHMS_PROPOSAL.js` (obsoleto)
- `mcp/tools/lib/ast-analyzer.js`

Además: reemplazo de `console.*` con `logger` en `AnalysisWorker.js`, `batch.js`, `isolation.js`, `load-config.js`, `system-map-enhancer.js`.

---

### v0.9.23 — Últimos wrappers + migración alias `ChangeType`

**13 archivos modificados — 280 eliminaciones**

- Migración de `cache/manager/*` de `constants.js` deprecated a imports canónicos desde `#config/change-types.js` y `#config/paths.js`
- Eliminado `cache/manager/constants.js`
- Eliminados aliases deprecated `ChangeType`/`CacheChangeType`/`BatchChangeType` de `config/change-types.js` y `config/index.js`
- Eliminados 4 wrappers zero-caller: `services/llm-service/LLMService.js`, `cache/response-cache.js`, `prompt-engine/PROMPT_REGISTRY.js`, `pipeline/enhancers/legacy/system-map-enhancer.js`
- Resultado: `@deprecated` reducido a 3 ocurrencias (solo en implementaciones reales)

---

### v0.9.24 — Fix 3 broken imports post-wrapper-deletion

**4 archivos modificados**

- `validation/core/rules/ValidationRule.js`: `../validation-result.js` (eliminado) → `../results/index.js`
- `prompt-engine/prompt-selector.js`: `./PROMPT_REGISTRY.js` (eliminado) → `./prompt-registry/index.js`
- `orchestrator/llm-analysis.js` (dynamic import): mismo fix
- `ground-truth-validator/validation-context.js`: `console.error` → `logger.error`

---

### v0.9.25 — Fix `getUnifiedCache` inexistente en atom-updater

**1 archivo modificado**

`getUnifiedCache` nunca existió en `cache/manager/index.js`. Reemplazado por `getCacheManager` de `singleton.js` (la API correcta).

- `src/core/atomic-editor/utils/atom-updater.js`

---

### v0.9.26 — Fix 5 broken imports en error-guardian y pipeline

**5 archivos modificados**

- `error-guardian/exports.js` y `guardian/index.js`: `error-classifier.js` → `error-classifier/index.js`, `recovery-handler.js` → `recovery-handler/index.js`
- `orchestrator/index.js`: `lifecycle.js` → `lifecycle/index.js`
- `pipeline/enhancers/metadata-enhancer.js`: `lineage-validator.js` → `lineage-validator/index.js`
- `pipeline/phases/atom-extraction/builders/enrichment.js`: mismo fix

---

### v0.9.27 — 0 broken imports verificado + restauración de archivo eliminado por error

**7 archivos modificados**

Usando el script propio `detect-broken-imports.js` del proyecto:

Fixes finales:
- `shadow-registry/ShadowRegistry.js` y `ancestry-enricher.js`: `lineage-tracker.js` → `lineage-tracker/index.js`
- `unified-server/index.js`: `tools.js` → `tools/index.js`
- `unified-server/tools/index.js`: `atomic-tools.js` → `atomic/atomic-tools.js`
- `issue-manager/index.js`: `issue-manager.js` → `issue-manager/index.js`

**⚠️ Caso especial — restauración:**
`pipeline/enhancers/legacy/system-map-enhancer.js` fue eliminado en v0.9.23 creyendo que era un wrapper zero-caller, pero tenía callers activos via `enhancers/index.js` → `indexer.js`. Se restauró desde git con migración `console.log` → `logger` y fix en su import interno (`risk-scorer.js` → `tier3/index.js`).

Resultado: `detect-broken-imports.js` reporta **ZERO broken imports en 1152 archivos**.

---

### v0.9.28 — Fix 10 broken imports en tests + exports en services/index.js

**12 archivos modificados**

- `PatternDetectionEngine.js`: `shared-objects-detector.js` → `shared-objects-detector/index.js` (dynamic path)
- 7 test files con rutas planas → subdirectory `index.js`:
  - `data-integrity-validator.js` → `data-integrity-validator/index.js`
  - `derivation-engine.js` → `derivation-engine/index.js`
  - `ground-truth-validator.js` → `ground-truth-validator/index.js`
  - `consistency-validator.js` → `consistency/index.js`
  - `integrity-validator.js` → `integrity/index.js`
  - `file-query.js` → `file-query/index.js` (2 test files)
- `ai.test.js`: mock path `#services/llm-service.js` → `llm-service/index.js`
- `services/index.js`: añadidos exports `analyzeWithLLM`, `isLLMAvailable`, `waitForLLM`
- `analyses-group3.test.js`: añadido `averageRisk` a `expectedSafeResult` para `deep-chains`

Resultado: **294/294 test suites passing, 4314 tests green, 0 failures**

---

## Bloque 2 — Omny Preprocessor Framework (NUEVO)

### ¿Para qué sirve?

El preprocessor **NO modifica código del usuario** ni arregla bugs de sintaxis en proyectos analizados. Su rol es exclusivamente interno a Layer A:

> Resuelve ambigüedades léxicas que confunden a Babel ANTES del parseo, para que el AST resultante sea más preciso.

El caso concreto que lo motivó: el símbolo `#` en JavaScript tiene **tres significados incompatibles** en Babel:

| Contexto | Ejemplo | Acción |
|----------|---------|--------|
| Shebang | `#!/usr/bin/env node` | Reemplazar con placeholder |
| Private field | `class A { #field }` | Reemplazar con placeholder |
| Pipeline topic (Hack) | `data \|> f(#)` | Mantener (para Babel) |

Sin el preprocessor, activar `pipelineOperator` en Babel rompía el parseo de archivos con shebang. Con el preprocessor, cada contexto se maneja correctamente según las reglas declarativas.

### Estructura creada

```
src/layer-a-static/preprocessor/
├── index.js                    # Entry point — createPreprocessor(), preprocessJavaScript()
├── context-model.js            # ContextModel — stack de contextos léxicos
├── token-classifier.js         # TokenClassifier + RuleBuilder
├── engine.js                   # PreprocessorEngine — motor principal (11 métodos)
├── handlers/
│   ├── javascript.js           # 4 reglas para # en JavaScript
│   └── typescript.js           # Extiende JS con contextos TypeScript
└── experimental/               # ⚠️ AISLADO — no conectado al pipeline principal
    └── ast-mapper.js           # AST restoration (desconectado por defecto)
```

### Estado de integración

**El preprocessor está AISLADO del pipeline principal** — esto es intencional.

- `createPreprocessor` y `preprocessJavaScript`: `calledBy: 0` (confirmado por MCP)
- No se activa hasta que se integre explícitamente en `src/layer-a-static/parser/config.js`
- El `ast-mapper.js` experimental permanece desconectado hasta validación completa

### ¿Por qué no se integra ahora?

El sistema ya funciona estable con `allowHashBang: true` como workaround. La integración del preprocessor al pipeline es el siguiente paso natural pero requiere:
1. Validar con archivos reales que usen pipeline operator + private fields simultáneamente
2. Asegurar que el AST Mapper restaure correctamente los placeholders post-parseo
3. Testear que no degrada el rendimiento del scan de 1700+ archivos

### Tests

49 tests unitarios en `tests/unit/layer-a-static/preprocessor/preprocessor.test.js`

**Resultado total:** 295 test files · 4,358 tests passing · 0 failed (1 preexistente en `prompt-builder.test.js` no relacionado)

---

## Bloque 3 — MCP Stability + True Restart

### Fix: Log de sesión limpio al arranque

**Archivo:** `src/layer-c-memory/mcp-server.js`

**Problema:** El log `logs/mcp-server.log` acumulaba output de sesiones anteriores. Al usar `Get-Content -Tail 50` en el viewer bat, los errores de sesiones previas aparecían mezclados con los de la sesión actual, causando confusión.

**Fix:** Truncar el log file al inicio de cada sesión, antes de redirigir stderr:

```js
// Truncate log file at session start so each new MCP session starts clean
fs.writeFileSync(logFile, '');
```

**Impacto:** El viewer de logs ahora muestra solo la sesión activa.

### Arquitectura: Proxy + Worker para restart verdadero de Node.js

**Archivos:** `src/layer-c-memory/mcp-server.js` (reescrito), `src/layer-c-memory/mcp-server-worker.js` (nuevo), `src/layer-c-memory/mcp/tools/restart-server.js`

**Problema raíz:** El `restart_server` anterior solo reiniciaba componentes internos (cache, orchestrator). Los módulos ESM de Node.js son inmutables en cache una vez cargados — no hay equivalente a `delete require.cache`. El único fix real requería reiniciar el proceso Node.js, pero eso cortaría el pipe stdio con Claude Code, perdiendo la sesión entera.

**Solución — Proxy + Worker:**

```
Claude Code  ←── stdio ──→  [mcp-server.js (proxy)]  ←── IPC + pipes ──→  [mcp-server-worker.js]
                               (nunca muere)                                   (se puede reiniciar)
```

- `mcp-server.js` se convierte en un proxy liviano que solo gestiona el pipe stdio y el ciclo de vida del worker
- `mcp-server-worker.js` contiene toda la lógica real (OmnySysMCPServer, herramientas, LLM, etc.)
- Cuando `restart_server` se llama, el worker envía `process.send({ type: 'restart' })` al proxy
- El proxy espera 300ms (para que la respuesta MCP llegue a Claude Code), mata el worker con SIGTERM, y spawna un proceso Node.js nuevo
- El nuevo proceso arranca con ESM cache vacío — todos los módulos se recargan desde disco
- La conexión stdio de Claude Code **nunca se interrumpe** — no se pierde el contexto

**Beneficio adicional:** auto-restart en crash. Si el worker muere inesperadamente, el proxy lo reinicia en 1 segundo. La sesión de Claude Code sobrevive crashes del servidor MCP.

**Backwards compatible:** `restart_server` detecta si `process.send` está disponible. Si se corre el worker directamente (sin proxy), cae al comportamiento anterior de reinicio de componentes.

### Fix: `analyze_signature_change` no encontraba class-methods

**Archivos:** `src/layer-c-memory/mcp/tools/lib/analysis/call-graph-analyzer.js`, `signature-analyzer.js`

**Síntoma:** Retornaba `"Symbol not found"` para métodos de clase (ej: `PreprocessorEngine.preprocess`).

**Causa 1 — `call-graph-analyzer.js`:** El lookup chequeaba `d.name === symbolName` pero los métodos de clase se almacenan como `"ClassName.methodName"` en definitions.
```js
// Antes
d.name === symbolName || d.name === symbolName
// Después
d.name === symbolName || d.name?.endsWith(`.${symbolName}`)
```

**Causa 2 — `signature-analyzer.js`:** El regex solo matcheaba `export function name(...)`, no métodos de clase.
```js
// Añadidos patrones:
new RegExp(`(?:^|\\s)(?:async\\s+)?${symbolName}\\s*\\(([^)]*)\\)\\s*\\{`, 'm'),  // class method
new RegExp(`static\\s+(?:async\\s+)?${symbolName}\\s*\\(([^)]*)\\)`, 'm'),         // static method
```

### Fix: `linesOfCode: 1` y `complexity: 1` falsos en class-methods

**Archivo:** `src/layer-a-static/parser/index.js`

**Causa:** `parseFileFromDisk()` leía el contenido del archivo en `code` pero nunca lo almacenaba en `fileInfo`. `indexer.js` hacía `parsedFile.source || ''` → obtenía `''`. Entonces `extractFunctionCode('', {line:83, endLine:114})` devolvía `''` → `linesOfCode: 1`, `complexity: 1`.

**Fix:** Añadido `fileInfo.source = code` antes del return en `parseFileFromDisk`.

### Fix: `Chain building failed: buildMolecularChains is not a function`

**Archivo:** `src/layer-a-static/pipeline/phases/chain-building-phase.js`

**Causa:** Importaba `{ buildMolecularChains, enrichAtomsWithChains }` de `molecular-chains/index.js` — funciones que no existen. La API correcta es `ChainBuilder` (clase).

**Fix:**
```js
// Antes (roto)
const { buildMolecularChains, enrichAtomsWithChains } = await import('../molecular-chains/index.js');
const chainData = buildMolecularChains(atoms);
const enrichedAtoms = enrichAtomsWithChains(atoms, chainData);

// Después (correcto)
const { ChainBuilder } = await import('../molecular-chains/index.js');
const chainData = new ChainBuilder(atoms).build();
```

### Fix: `Cannot read properties of undefined (reading 'map')` en file-watcher

**Archivo:** `src/core/file-watcher/analyze.js`

**Causa:** `advancedConnections.connections.map(...)` en línea 184 — `detectAllAdvancedConnections()` devuelve un objeto con `.all` (getter) pero no tiene propiedad `.connections`.

**Fix:** Reemplazado `.connections` por `.all`:
```js
// Antes
...advancedConnections.connections.map(conn => ({
// Después
...(advancedConnections.all || []).map(conn => ({
```

---

## Impacto en Tests

| Métrica | Antes (v0.9.18) | Ahora (v0.9.29) |
|---------|-----------------|-----------------|
| Test Files | 293 | 295 |
| Tests passing | 4,308 | 4,358 |
| Broken imports | ~25 | **0** |
| Failed | 0 | 0 (1 preexistente) |

---

## Archivos Creados

### Source (Preprocessor Framework)
- `src/layer-a-static/preprocessor/index.js`
- `src/layer-a-static/preprocessor/context-model.js`
- `src/layer-a-static/preprocessor/token-classifier.js`
- `src/layer-a-static/preprocessor/engine.js`
- `src/layer-a-static/preprocessor/handlers/javascript.js`
- `src/layer-a-static/preprocessor/handlers/typescript.js`
- `src/layer-a-static/preprocessor/experimental/ast-mapper.js`

### Tests
- `tests/unit/layer-a-static/preprocessor/preprocessor.test.js`

## Archivos Modificados

- `src/layer-c-memory/mcp-server.js` — reescrito como proxy (stdio manager + worker lifecycle)
- `src/layer-c-memory/mcp-server-worker.js` — NUEVO: lógica real del servidor (restartable)
- `src/layer-c-memory/mcp/tools/restart-server.js` — usa `process.send()` para true restart vía proxy
- `src/layer-c-memory/mcp/tools/lib/analysis/call-graph-analyzer.js` — fix class-method lookup (`endsWith`)
- `src/layer-c-memory/mcp/tools/lib/analysis/signature-analyzer.js` — fix regex para métodos de clase y static
- `src/layer-a-static/parser/index.js` — añadido `fileInfo.source = code` para fix `linesOfCode`/`complexity`
- `src/layer-a-static/pipeline/phases/chain-building-phase.js` — reemplazado `buildMolecularChains` por `ChainBuilder`
- `src/core/file-watcher/analyze.js` — reemplazado `.connections` por `.all` en `advancedConnections`
- `src/layer-a-static/parser/config.js` — `allowHashBang: true`
- `src/layer-a-static/extractors/data-flow/index.js` — remove `pipelineOperator` plugin
- Múltiples test files — imports a wrappers eliminados corregidos
