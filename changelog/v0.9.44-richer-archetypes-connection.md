# v0.9.44 - Richer Archetypes + Connection Bridge Detection

## Resumen

Dos upgrades que usan la metadata rica ya disponible para dar más precisión
al clasificar funciones y detectar conexiones entre archivos.

---

## 1. Arquetipos enriquecidos — de 8 a 14 tipos

### Antes (solo 8 tipos)
`god-function`, `fragile-network`, `hot-path`, `dead-function`,
`class-method`, `private-utility`, `utility`, `standard`

El 80% de los atoms caía en `standard` — no decía nada.

### Ahora (14 tipos)
Se agregan 6 nuevos usando metadata que ya existía pero no se usaba:

| Archetype | Señal principal | Ejemplo |
|---|---|---|
| `orchestrator` | couplingScore ≥ 6 + ≥4 llamadas internas + isExported | `handleFileDeleted` (llama 9 fns) |
| `handler` | nombre `handle*`/`on*` o `dna.semanticFingerprint` starts with `"handle:"` | `handleFileModified`, `handleFileCreated` |
| `factory` | nombre `create*`/`build*`/`make*`/`generate*` | `buildAtomIndex`, `createShadowsForFile` |
| `initializer` | nombre `init*`/`setup*`/`start*`/`bootstrap*` | `initialize`, `setupServer` |
| `transformer` | `dna.flowType = "read-transform-return"` + sin side effects | extractors, parsers puros |
| `persister` | `dna.flowType = "read-persist-return"` o nombre `save*`/`load*`/`get*` + async | `saveAtom`, `loadAtoms` |

### Metadata que ahora se usa en archetype detection
- `dna.flowType` — clasificación estructural del flujo de datos
- `dna.semanticFingerprint` — huella semántica ("handle:core:modified")
- `derived.couplingScore` — cuántas funciones dependen de esta
- Patrones de nombre (`/^(handle|create|init|save|...)`)
- `internalCalls` — coordinación intra-módulo (orchestrator)

---

## 2. `explain_connection` — detección de puente mixin

### Antes
Solo detectaba conexiones directas (A importa B). El patrón mixin retornaba
`"connected: false"` aunque A y B estuvieran conectadas via prototype delegation.

### Ahora — 3 niveles de fallback adicionales

**Nivel 1 — calledBy cruzado (mixin this.*)**:
Busca atoms de B que aparezcan en `calledBy` de atoms de A (o viceversa).
Detecta exactamente el patrón `Object.assign(X.prototype, handlers)` + `this.fn()`.

```json
{
  "type": "mixin-call",
  "direction": "lifecycle.js → calls (via this.*) → handlers.js",
  "reason": "lifecycle.js calls functions defined in handlers.js via mixin/prototype delegation"
}
```

**Nivel 2 — shared-dependency**:
Si ambos archivos importan el mismo módulo C, son dependientes comunes.
Útil para detectar que dos archivos "viven en el mismo subsistema".

**Nivel 3** — (existente, mejorado) — eventos compartidos.

---

## Archivos modificados

- `src/layer-a-static/pipeline/phases/atom-extraction/metadata/archetype.js`
  — 14 arquetipos, usa dna + couplingScore + nombre
- `src/layer-c-memory/mcp/tools/connection.js`
  — 3 niveles de fallback para conexiones indirectas
